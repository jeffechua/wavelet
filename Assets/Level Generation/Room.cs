using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System;
using System.Linq;


public abstract class RoomObject : MonoBehaviour {
	Room _room;
	protected Room room {
		get {
			if (!_room) {
				_room = transform.root.GetComponent<Room>();
			}
			return _room;
		}
	}
	public void OverrideRoom(Room newRoom) {
		_room = newRoom;
	}

	bool prePauseEnablementState;
	public void Pause() {
		prePauseEnablementState = enabled;
		enabled = false;
	}
	public void Unpause() {
		enabled = prePauseEnablementState;
	}
}

public interface Configurable {
	void Configure(string[] args); // Note that first argument is gameObject-label.component-name
}

[Serializable]
public enum BorderType { Closed = 0, Free = 1, Absorb = 2 }

[Serializable]
public class BorderData {
	public BorderType type;
	public float thickness;
	public bool door;
}

[Serializable]
public class ObjectData {
	public string templateName;
	public GameObject template;
	public float x = 0;
	public float y = 0;
	public Vector2 position { get => new Vector2(x, y); }
	public float xScale = 1;
	public float yScale = 1;
	public Vector2 scale { get => new Vector2(xScale, yScale); }
	public float angle = 0;
	public string label;
}

[Serializable]
public struct ConfigData {
	public string label;
	public string component;
	public string[] args;
}

[Serializable]
public class RoomData {
	public string name;
	public float width;
	public float height;
	public float timeScale;
	public WaveEngineParams weParams;
	public BorderData[] borders;
	public ObjectData[] enemies;
	public ObjectData[] things;
	public ConfigData[] configs;
}

public class Room : MonoBehaviour {

	public static Room active;

	public bool[] doors;

	public string dataPath;
	public RoomData data;

	public Vector2 size { get => new Vector2(data.width,data.height); }
	public float timeScale { get => data.timeScale; }
	public float deltaTime { get => Time.deltaTime * data.timeScale; }

	public GameObject waveEngineTemplate;
	public GameObject borderTemplate;
	public WaveEngine waveEngine; // Autogenerated, do not assign.

	// Named room objects have two purposes:
	// 1) Names are used to find targets of config commands
	// 2) Named objects are tracked and exposed in the named Dictionary
	public Dictionary<string, GameObject> named = new Dictionary<string, GameObject>();

	public Rect rect {
		get => new Rect((Vector2)transform.position - size / 2, size);
	}

	public void ResetRoom() {
		gameObject.BroadcastMessage("Reset", SendMessageOptions.DontRequireReceiver);
	}

	public void PauseRoom() {
		gameObject.BroadcastMessage("Pause", SendMessageOptions.DontRequireReceiver);
	}

	public void UnpauseRoom() {
		gameObject.BroadcastMessage("Unpause", SendMessageOptions.DontRequireReceiver);
	}

	public void ImportData(string text) {
		// Split data by section delimiter '$'
		// Then split into lines (delimiter '\n')
		// And remove all empty lines or commented '#' lines
		// And trim remaining lines.
		data = JsonUtility.FromJson<RoomData>(text);
		for (int i = 0; i < 4; i++)
			data.borders[i].door = data.borders[i].door && doors[i];
		foreach (ObjectData enemy in data.enemies)
			enemy.template = (GameObject)Resources.Load("Enemy/" + enemy.templateName);
		foreach (ObjectData thing in data.things)
			thing.template = (GameObject)Resources.Load("Things/" + thing.templateName);
	}

	public void ReloadRoom() {

		// Destroy all instantiated objects (except WavePlane)
		for (int i = 0; i < transform.childCount; i++)
			Destroy(transform.GetChild(i).gameObject);

		// Clear named dictionary
		named.Clear();

		// Instance wave engine and plane
		waveEngine = Instantiate(waveEngineTemplate, transform).GetComponent<WaveEngine>();
		waveEngine.transform.localPosition = Vector3.forward;
		waveEngine.param = data.weParams;
		waveEngine.transform.localScale = new Vector3(data.width, data.height, 1);
		waveEngine.Initialize();

		// Instance room borders
		for (int i = 0; i < 4; i++)
			Instantiate(borderTemplate, transform).GetComponent<Border>().Draw(data.borders[i], i);

		// Instance enemies
		foreach (ObjectData enemy in data.enemies) {
			GameObject instance = Instantiate(enemy.template, enemy.position + (Vector2)transform.position, Quaternion.Euler(0, 0, enemy.angle) * transform.rotation, transform);
			instance.transform.localScale = new Vector3(enemy.scale.x, enemy.scale.y, 1);
			if (enemy.label != null) named.Add(enemy.label, instance);
		}

		// Instance things
		foreach (ObjectData thing in data.things) {
			GameObject instance = Instantiate(thing.template, thing.position + (Vector2)transform.position, Quaternion.Euler(0, 0, thing.angle) * transform.rotation, transform);
			instance.transform.localScale = new Vector3(thing.scale.x, thing.scale.y, 1);
			if (thing.label != null) named.Add(thing.label, instance);
		}

		// Execute configs
		foreach (ConfigData config in data.configs) {((Configurable)named[config.label].GetComponent(config.component)).Configure(config.args);
		}

		if (active == this) {
			waveEngine.SetActive();
		} else {
			PauseRoom();
		}
	}

	public void Awake() {
		if (dataPath == "")
			return;
		string text = Resources.Load<TextAsset>("Rooms/" + dataPath).text;
		if (text == null)
			return;
		ImportData(text);
		ReloadRoom();
	}

	private void Update() {

		if (Input.GetKeyDown(KeyCode.R)) {
			if (Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift))
				ReloadRoom();
			else
				ResetRoom();
		}

		// Couple player hitbox if overlapping
		if (Player.instance == null)
			return;

		bool containsPlayer = rect.Contains(Player.instance.transform.position);

		if (containsPlayer && active != this) {
			if (active != null) active.PauseRoom();
			active = this;
			UnpauseRoom();
			waveEngine.SetActive();
			Player.instance.GetComponent<HP>().OverrideRoom(this); // probably don't need to do this every frame
			Player.instance.GetComponent<DamageHitbox>().OverrideRoom(this); // probably don't need to do this every frame
		} else if (!containsPlayer && active == this) {
			active.PauseRoom();
			active = null;
		}

	}

}
