using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System;
using System.Linq;


public abstract class RoomObject : MonoBehaviour {
	Room _room;
	protected Room room {
		get {
			if (!_room) {
				_room = transform.root.GetComponent<Room>();
			}
			return _room;
		}
	}
	public void OverrideRoom(Room newRoom) {
		_room = newRoom;
	}

	bool prePauseEnablementState;
	public void Pause() {
		prePauseEnablementState = enabled;
		enabled = false;
	}
	public void Unpause() {
		enabled = prePauseEnablementState;
	}
}

public interface Configurable {
	void Configure(string[] args); // Note that first argument is gameObject-label.component-name
}

public enum BorderType { Closed = 0, Free = 1, Absorb = 2 }

[Serializable]
public struct BorderParams {
	public BorderType type;
	public float thickness;
	public bool door;
}

[Serializable]
public struct ObjectParams {
	public GameObject template;
	public Vector2 position;
	public Vector2 scale;
	public float angle;
	public string label;
}

public class Room : MonoBehaviour {

	public static Room active;

	public bool[] doors;
	public string path;

	public Vector2 size;
	public float timeScale;
	public float deltaTime { get => Time.deltaTime * timeScale; }

	WaveEngineParams weParams;
	BorderParams[] borders;
	ObjectParams[] enemies;
	ObjectParams[] things;
	string[][] configs;

	public GameObject waveEngineTemplate;
	public GameObject borderTemplate;
	public WaveEngine waveEngine; // Autogenerated, do not assign.

	// Named room objects have two purposes:
	// 1) Names are used to find targets of config commands
	// 2) Named objects are tracked and exposed in the named Dictionary
	public Dictionary<string, GameObject> named = new Dictionary<string, GameObject>();

	public Rect rect {
		get => new Rect((Vector2)transform.position - size / 2, size);
	}

	public void ResetRoom() {
		gameObject.BroadcastMessage("Reset", SendMessageOptions.DontRequireReceiver);
	}

	public void PauseRoom() {
		gameObject.BroadcastMessage("Pause", SendMessageOptions.DontRequireReceiver);
	}

	public void UnpauseRoom() {
		gameObject.BroadcastMessage("Unpause", SendMessageOptions.DontRequireReceiver);
	}

	public void Parse(string data) {
		// Split data by section delimiter '$'
		// Then split into lines (delimiter '\n')
		// And remove all empty lines or commented '#' lines
		// And trim remaining lines.
		var words = data.Split('$')                                                 // Split into sections by '$'
			.Select((section) => section.Split(';')                                // Split into lines by '\n'
				.Where((line) => !line.Trim().StartsWith("#") && line.Trim() != "") // Remove empty lines and comments '$'
				.Select((line) => line.Split(':')                                   // Split into words by ':'
					.Select((word) => word.Trim()).ToArray()).ToArray()).ToArray(); // Trim

		try {
			size = new Vector2(float.Parse(words[1][0][0]), float.Parse(words[1][0][1]));
			timeScale = float.Parse(words[1][0][2]);
		} catch {
			throw new ArgumentException("Could not parse room section (1) of " + words[0][0][0] + ".");
		}

		try {
			weParams = new WaveEngineParams {
				amplitudeScale = float.Parse(words[2][0][0]),
				amplitudeThreshold = float.Parse(words[2][0][1]),
				subThresholdMultiplier = float.Parse(words[2][0][2]),
				pixelSize = float.Parse(words[2][0][3]),
				frequency = int.Parse(words[2][0][4]),
				cScale = float.Parse(words[2][0][5]),
				dampingScale = float.Parse(words[2][0][6]),
				sourceFrequencyScale = float.Parse(words[2][0][7])
			};
		} catch {
			throw new ArgumentException("Could not parse wave engine section (2) of " + words[0][0][0] + ".");
		}

		try {
			borders = words[3].Select((line, i) => new BorderParams {
				type = (BorderType)Enum.Parse(typeof(BorderType), line[0], true),
				thickness = float.Parse(line[1]),
				door = bool.Parse(line[2]) && doors[i]
			}).ToArray();
		} catch {
			throw new ArgumentException("Could not parse borders section (3) of " + words[0][0][0] + ".");
		}

		try {
			enemies = words[4].Select((line, i) => new ObjectParams {
				template = (GameObject)Resources.Load("Enemy/" + line[0]),
				position = new Vector2(float.Parse(line[1]), float.Parse(line[2])),
				scale = new Vector2(float.Parse(line[3]), float.Parse(line[4])),
				angle = line.Length >= 6 ? float.Parse(line[5]) : 0,
				label = line.Length >= 7 ? line[6] : null
			}).ToArray();
		} catch {
			throw new ArgumentException("Could not parse enemies section (4) of " + words[0][0][0] + ".");
		}

		try {
			things = words[5].Select((line, i) => new ObjectParams {
				template = (GameObject)Resources.Load("World/" + line[0]),
				position = new Vector2(float.Parse(line[1]), float.Parse(line[2])),
				scale = new Vector2(float.Parse(line[3]), float.Parse(line[4])),
				angle = line.Length >= 6 ? float.Parse(line[5]) : 0,
				label = line.Length >= 7 ? line[6] : null
			}).ToArray();
		} catch {
			throw new ArgumentException("Could not parse world section (5) of " + words[0][0][0] + ".");
		}

		try {
			configs = words[6];
		} catch {
			throw new ArgumentException("Could not configs world section (5) of " + words[0][0][0] + ".");
		}

	}

	public void ReloadRoom() {

		// Destroy all instantiated objects (except WavePlane)
		for (int i = 0; i < transform.childCount; i++)
			Destroy(transform.GetChild(i).gameObject);

		// Clear named dictionary
		named.Clear();

		// Instance wave engine and plane
		waveEngine = Instantiate(waveEngineTemplate, transform).GetComponent<WaveEngine>();
		waveEngine.transform.localPosition = Vector3.forward;
		waveEngine.LoadParams(weParams, size);
		waveEngine.Initialize();

		// Instance room borders
		for (int i = 0; i < 4; i++)
			Instantiate(borderTemplate, transform).GetComponent<Border>().Draw(borders[i], i);

		// Instance enemies
		foreach (ObjectParams enemy in enemies) {
			GameObject instance = Instantiate(enemy.template, enemy.position + (Vector2)transform.position, Quaternion.Euler(0, 0, enemy.angle) * transform.rotation, transform);
			instance.transform.localScale = new Vector3(enemy.scale.x, enemy.scale.y, 1);
			if (enemy.label != null) named.Add(enemy.label, instance);
		}

		// Instance things
		foreach (ObjectParams thing in things) {
			GameObject instance = Instantiate(thing.template, thing.position + (Vector2)transform.position, Quaternion.Euler(0, 0, thing.angle) * transform.rotation, transform);
			instance.transform.localScale = new Vector3(thing.scale.x, thing.scale.y, 1);
			if (thing.label != null) named.Add(thing.label, instance);
		}

		// Execute configs
		foreach (string[] config in configs) {
			string[] halves = config[0].Split('.');
			((Configurable)named[halves[0]].GetComponent(halves[1])).Configure(config);
		}

		if (active == this) {
			waveEngine.SetActive();
		} else {
			PauseRoom();
		}
	}

	public void Awake() {
		if (path == "")
			return;
		string data = Resources.Load<TextAsset>("Rooms/" + path).text;
		if (data == null)
			return;
		Parse(data);
		ReloadRoom();
	}

	private void Update() {

		if (Input.GetKeyDown(KeyCode.R)) {
			if (Input.GetKey(KeyCode.LeftShift) || Input.GetKey(KeyCode.RightShift))
				ReloadRoom();
			else
				ResetRoom();
		}

		// Couple player hitbox if overlapping
		if (Player.instance == null)
			return;

		bool containsPlayer = rect.Contains(Player.instance.transform.position);

		if (containsPlayer && active != this) {
			if (active != null) active.PauseRoom();
			active = this;
			UnpauseRoom();
			waveEngine.SetActive();
			Player.instance.GetComponent<HP>().OverrideRoom(this); // probably don't need to do this every frame
			Player.instance.GetComponent<DamageHitbox>().OverrideRoom(this); // probably don't need to do this every frame
		} else if (!containsPlayer && active == this) {
			active.PauseRoom();
			active = null;
		}

	}

}
